>   **SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#1 – Introduction to Testing and Defect Tracking**

| Group: Group Number      |
|-----------------|
| Student 1: Sufyan Ayaz                |   
| Student 2: Muhammad Haris Kashif              |   
| Student 3: Faisal Islam               |   
| Student 4: Taha Khan                |   


**Table of Contents**

(When you finish writing, update the following list using right click, then
“Update Field”)

[1 Introduction	1](#_Toc439194677)

[2 High-level description of the exploratory testing plan	1](#_Toc439194678)

[3 Comparison of exploratory and manual functional testing	1](#_Toc439194679)

[4 Notes and discussion of the peer reviews of defect reports	1](#_Toc439194680)

[5 How the pair testing was managed and team work/effort was
divided	1](#_Toc439194681)

[6 Difficulties encountered, challenges overcome, and lessons
learned	1](#_Toc439194682)

[7 Comments/feedback on the lab and lab document itself	1](#_Toc439194683)

# Introduction

In this lab, we were given the opportunity to employ real life testing methodologies as a way to introduce ourselves to software testing, and to gain a comprehensive understanding of the foundational principles that would allow us to succeed in the realm of testing. We were given access to two versions of an ATM application (an initial version and an updated version) and were given the task of isolating potential bugs that the application may have. The process of debugging the application involved three different types of software testing techniques: exploratory testing, manual functional testing, and regression testing. Before beginning this lab, our group had a prior familiarity with two of the techniques: exploratory testing and manual functional testing. With regards to exploratory testing, this was the testing technique that our team first employed after reading over the application description. The members of our team had not ever attempted to debug an application using this technique (prior to this lab), but we were all familiar with the workings of the technique and how it involved finding bugs through the use of ones cognitive abilities and understanding of the application’s design. After exploratory testing, the next testing technique we employed was the manual functional testing technique. When it comes to manual functional testing, our team had the most knowledge of this testing method having practically experienced it in the past. We understood that the technique involved verifying the basic functionality of the application using a set of predetermined test cases, and because of our previous experience with this method, this was the testing technique that was easiest for us to grasp and execute. Finally, we employed the regression testing technique, where our team had re-ran test cases in the updated version of the ATM application to monitor the resolution status of old bugs, or the appearance of new bugs. The members of our team had no prior experience or knowledge of this testing technique, but it was relatively easy to understand, so we didn’t have issues with this technique.

# High-level description of the exploratory testing plan

Text…

# Comparison of exploratory and manual functional testing

Exploratory testing and manual functional testing were two of the testing techniques that our team employed during the testing of the ATM application. Both testing methods have their own respective benefits, but they do differ in terms of their execution and what they are able to achieve.

Exploratory testing is a lot more flexible than manual functional testing. It’s more of a trial and error type testing technique that really relies on the tester being familiar with how the application is designed to work, so they can try to find bugs on the path that a normal user would take. This testing technique takes away from the pressure of ensuring that the application is meeting a certain standard at every step and really just allows the tester to learn about and experience the application as a user, which can lead to them finding the random, edge-case bugs that they wouldn’t normally be able to find if they were sticking to a plan. This testing also allows for debugging of newer systems to become easier as it doesn’t require the tester to know everything about the application. Even though exploratory testing may seem like a very effective testing method, it does have drawbacks that can take away from its effectiveness. The most significant drawback is that exploratory testing is very time consuming. Not knowing what bugs they are trying to find can lead to testers spending a long time repeating the same actions and not finding new bugs, which can be quite detrimental if there are deadlines during the testing phase of the application. Also, the effectiveness of exploratory testing quite heavily relies on the ability of the tester themselves. If the tester is not able to properly acquaint themselves with the application design, is not very experienced, or is not very creative, they can very easily miss a lot of bugs and render the testing as being ineffective. Another drawback that exploratory testing faces is that this technique does not work very well when it comes to large applications. Our ATM application was quite small, which made exploratory testing feasible, but exploratory testing on large application would not yield a similar success rate. The lack of a plan when testing a large system can make it very hard to find all the bugs, and is most likely going to result in many bugs being overlooked. A third drawback that arises when using exploratory testing is that sometimes, when testers stumble upon random edge-case bugs, it can be difficult to reproduce the same bug as those bugs are found in unexpected places.

In contrast to exploratory testing, manual functional testing is all about testing applications in a rigid, systematic fashion. This method involves having a detailed testing plan, in the form of test cases in a testing suite, that will cover all the important functionalities of the application, and will ensure that they are up to standard. Having a plan of action allows for this method to be much more faster and effective when finding bugs in application, as testers already have a sense of what they are looking for and can directly go there. Since there is a plan involved for finding the bugs, it is also much more easier to reproduce bugs as testers would have the steps they took to find the bug in the first place. The manual functional testing method is also useful when it comes to testing large application, as time isn’t wasted and testers can be guided through the app through their test suite. Our ATM application was quite small, so a lot of the bugs were found during the exploratory testing phase, but when we were in the manual functional testing phase, we were able to find remaining bugs much faster as we now knew what to look for. Even though manual functional testing seems like quite a promising testing technique, it does have its own drawbacks as well. For starters, because of how systematic and planned out this testing technique is, it is very easy for testers to follow the plan to test that all the functionalities are working properly and overlook bugs that may exist within edge-cases as those cases are outside the planned tests (which is something we noticed when we were testing our ATM application and found that there were quite an amount of bugs that we found in the exploratory testing phase that weren’t covered by the test cases in the testing suite we were given). Another drawback that manual functional testing has is that because of how comprehensive it is, in order to predetermine such systematic test cases, the people coming up with the test cases need to have a very thorough and complete understanding of the application and all of its functionalities.

Both testing types have their own benefits and drawbacks, but what our team understood during this lab assignment was that the reason they both work very well together (and why they should both be used when testing software) is because of how they compliment each other. Both testing styles make up for the others drawbacks and together allow for a more comprehensive debugging/testing of applications.


# Notes and discussion of the peer reviews of defect reports

Text…

# How the pair testing was managed and team work/effort was divided 

Our team utilized Discord for communication. We split our team into two pairs: 
* Pair 1: Faisal Islam & Taha Khan
* Pair 2: Sufyan Ayaz & Muhammad Haris Kashif

For our exploratory testing, we tested different features of the application, in both versions. The way we divided this up was each pair sat with their respective partners and “played around” with the program and tested functionality to attempt to “break” the program and find bugs. Each partner tested a different version of the application, so one partner tested v1.0, and the other tested v1.1. We felt the most efficient way to cover our bases and ensure that we kept track of patched bugs and unpatched bugs between versions of the application was for each partner to replicate a bug on the version they were testing.  

For our manual scripted testing, Pair 1 tested cases 1-20, and Pair 2 tested cases 21-40. Furthermore, each pair worked on 10 test cases each, dividing the work up evenly among the four members of the team. We each regression tested our assigned cases in both versions. After testing and reporting the findings of our respective test cases, we reconvened with our pairs to kind of cross check and establish that there were minimal errors in our testing methodologies. 

Each pair and the individuals in each pair logged the bugs discovered within their exploratory and manual scripted testing. After we fully completed our testing, we reviewed the application once more as a group in an attempt to find more bugs we may have initially overlooked, and also to ensure that we completed our test cases correctly. 

# Difficulties encountered, challenges overcome, and lessons learned

Text…

# Comments/feedback on the lab and lab document itself

Sufyan: Overall, I felt this lab was quite beneficial for me. Being able to implement the three testing techniques together allowed for me to get a practical understanding of the basics of how software is tested in real life. This lab also gave me an insight into why these three testing techniques are used together and individually as well. One issue I did have with the lab is that I felt the instructions could have been a bit clearer with more comprehensive steps, as I found at times it was difficult to follow the instructions.
